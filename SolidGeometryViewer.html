<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>幾何透視實驗室</title>
    <style>
        :root { --primary: #2c3e50; --accent: #16a085; --bg: #f3f4f6; }
        
        /* 讓頁面可以捲動，解決按鈕看不到的問題 */
        html, body { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            font-family: 'Segoe UI', sans-serif; 
            background: var(--bg); 
            overflow-x: hidden; /* 防止左右晃動 */
            overflow-y: auto;   /* 允許上下捲動 */
            -webkit-overflow-scrolling: touch;
        }

        #app { 
            display: flex; 
            flex-direction: column; 
            min-height: 100vh;
            padding-bottom: 80px; /* 底部留白，避開 iPad 手勢條 */
        }

        header { 
            background: var(--primary); 
            color: white; 
            padding: 15px 20px; 
            font-size: 20px; 
            font-weight: bold; 
            text-align: center;
        }

        /* 工作區設定：保證有高度 */
        #workspace { 
            display: flex; 
            padding: 15px; 
            gap: 15px; 
            height: 50vh; /* 佔螢幕一半高度 */
            min-height: 350px; /* 死也不會縮得比這小 */
        }

        /* 手機或直立 iPad 時改為直排 */
        @media (max-width: 768px) {
            #workspace {
                flex-direction: column;
                height: auto; 
            }
            .panel {
                height: 350px; /* 強制給予高度 */
                width: 100%;
            }
        }

        .panel { 
            flex: 1; 
            background: white; 
            border-radius: 8px; 
            position: relative; 
            border: 2px solid #ccc; 
            overflow: hidden; 
        }

        .label { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            background: rgba(0,0,0,0.7); 
            color: white; 
            padding: 4px 10px; 
            border-radius: 4px; 
            font-size: 14px; 
            pointer-events: none; 
            z-index: 10;
        }

        canvas#sectionCanvas { width: 100%; height: 100%; display: block; }

        /* 按鈕區 */
        #controls { 
            background: white; 
            padding: 20px; 
            margin: 0 15px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex; 
            flex-direction: column; 
            gap: 15px; 
            align-items: center; 
        }

        .row { 
            display: flex; 
            gap: 10px; 
            flex-wrap: wrap; 
            justify-content: center; 
            align-items: center; 
        }

        button { 
            padding: 10px 18px; 
            border: 1px solid #aaa; 
            background: #fff; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 16px; 
            color: #444; 
        }
        button:active { background: #eee; }
        button.active { background: var(--primary); color: white; font-weight: bold; }
        .mode-btn.active { background: var(--accent); border-color: var(--accent); }

        .slider-group { 
            display: flex; 
            align-items: center; 
            gap: 10px; 
            background: #eee; 
            padding: 10px 20px; 
            border-radius: 30px; 
            width: 100%;
            max-width: 400px;
            justify-content: center;
        }
        input[type=range] { flex: 1; cursor: pointer; height: 25px; }
    </style>
</head>
<body>

<div id="app">
    <header>幾何截面模擬器 V14</header>
    
    <div id="workspace">
        <div class="panel" id="view3d">
            <div class="label">3D 立體視角 (可滑動旋轉)</div>
        </div>
        <div class="panel" id="view2d">
            <div class="label">2D 截面形狀</div>
            <canvas id="sectionCanvas"></canvas>
        </div>
    </div>

    <div id="controls">
        <div class="row">
            <button onclick="setShape('prism')" id="btn-prism">三角柱</button>
            <button onclick="setShape('cube')" id="btn-cube">正方體</button>
            <button onclick="setShape('cylinder')" id="btn-cylinder">圓柱體</button>
            <button onclick="setShape('cone')" id="btn-cone">圓錐體</button>
            <button onclick="setShape('tri_pyramid')" id="btn-tri_pyramid">三角錐</button>
            <button onclick="setShape('sq_pyramid')" id="btn-sq_pyramid">四角錐</button>
            <button onclick="setShape('sphere')" id="btn-sphere">球體</button>
        </div>
        <div class="row">
            <div class="row" style="margin-right: 20px;">
                <button onclick="setMode('horizontal')" id="mode-h" class="mode-btn">橫切 (—)</button>
                <button onclick="setMode('vertical')" id="mode-v" class="mode-btn">縱切 ( | )</button>
            </div>
            <div class="slider-group">
                <span>位置：</span>
                <input type="range" id="slider" min="-1.8" max="1.8" step="0.01" value="0">
            </div>
        </div>
        <div style="color:#888; font-size:12px; margin-top:5px;">
            提示：如果在 iPad 上看不到按鈕，請往下滑動畫面
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
    let scene, camera, renderer, mesh, slicePlane, controls;
    let currentShape = 'cone'; 
    let cutMode = 'vertical'; 
    
    const canvas2d = document.getElementById('sectionCanvas');
    const ctx2d = canvas2d.getContext('2d');
    const container3d = document.getElementById('view3d');
    const container2d = document.getElementById('view2d');

    // V12 的正確邏輯參數
    const SHAPES = {
        'sq_pyramid': { rTop: 0, rBot: 2.2, h: 4, seg: 4, rot: Math.PI/4, label: '四角錐' }, 
        'tri_pyramid': { rTop: 0, rBot: 2.2, h: 4, seg: 3, rot: 0, label: '三角錐' },
        'cone': { rTop: 0, rBot: 1.8, h: 4, seg: 64, rot: 0, label: '圓錐' },
        'cylinder': { rTop: 1.5, rBot: 1.5, h: 4, seg: 64, rot: 0, label: '圓柱' },
        'prism': { rTop: 1.5, rBot: 1.5, h: 4, seg: 3, rot: -Math.PI/6, label: '三角柱' },
        'cube': { w: 2.5, h: 2.5, d: 2.5, rot: 0, label: '正方體' },
        'sphere': { r: 1.8, label: '球體' }
    };

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xfcfcfc);
        
        camera = new THREE.PerspectiveCamera(45, container3d.clientWidth / container3d.clientHeight, 0.1, 100);
        camera.position.set(0, 3, 10); 
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container3d.clientWidth, container3d.clientHeight);
        container3d.appendChild(renderer.domElement);

        // 加入軌道控制器，讓操作更順手
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // 實體切板
        const planeGeo = new THREE.BoxGeometry(6, 6, 0.05); 
        const planeMat = new THREE.MeshPhongMaterial({ 
            color: 0x16a085, 
            transparent: true, 
            opacity: 0.5,
            side: THREE.DoubleSide
        });
        slicePlane = new THREE.Mesh(planeGeo, planeMat);
        scene.add(slicePlane);

        setShape('cone');
        setMode('vertical');

        window.addEventListener('resize', onResize);
        setTimeout(onResize, 100); // 確保載入後尺寸正確
        animate();
    }

    function onResize() {
        // 確保不為 0，避免錯誤
        const w = container3d.clientWidth || 300;
        const h = container3d.clientHeight || 300;
        
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);

        const w2 = container2d.clientWidth || 300;
        const h2 = container2d.clientHeight || 300;
        canvas2d.width = w2;
        canvas2d.height = h2;
        
        draw2d();
    }

    function setShape(type) {
        currentShape = type;
        if (mesh) scene.remove(mesh);
        
        const cfg = SHAPES[type];
        let geo;
        const mat = new THREE.MeshPhongMaterial({ color: 0x27ae60, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
        
        if (type === 'cube') {
            geo = new THREE.BoxGeometry(cfg.w, cfg.h, cfg.d);
        } else if (type === 'sphere') {
            geo = new THREE.SphereGeometry(cfg.r, 32, 32);
        } else {
            geo = new THREE.CylinderGeometry(cfg.rTop, cfg.rBot, cfg.h, cfg.seg);
        }

        mesh = new THREE.Mesh(geo, mat);
        if (cfg.rot) mesh.rotation.y = cfg.rot;
        
        scene.add(mesh);
        
        document.querySelectorAll('#controls button').forEach(b => {
            if(!b.classList.contains('mode-btn')) b.classList.remove('active');
        });
        document.getElementById('btn-' + type).classList.add('active');
        draw2d();
    }

    function setMode(mode) {
        cutMode = mode;
        const slider = document.getElementById('slider');
        slider.value = 0;

        if (mode === 'horizontal') {
            slicePlane.rotation.set(-Math.PI/2, 0, 0); 
        } else {
            slicePlane.rotation.set(0, Math.PI/2, 0); 
        }

        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(mode === 'horizontal' ? 'mode-h' : 'mode-v').classList.add('active');
        draw2d();
    }

    function draw2d() {
        const w = canvas2d.width;
        const h = canvas2d.height;
        const cx = w / 2;
        const cy = h / 2;
        const val = parseFloat(document.getElementById('slider').value);
        
        // 自動縮放邏輯，避免圖形太大或太小
        const scale = Math.min(w, h) / 7; 
        
        ctx2d.clearRect(0, 0, w, h);
        ctx2d.fillStyle = "#27ae60";
        ctx2d.lineWidth = 3;
        ctx2d.strokeStyle = "#145a32";
        ctx2d.beginPath();

        const cfg = SHAPES[currentShape];

        // 橫切 (Horizontal)
        if (cutMode === 'horizontal') {
            if (currentShape === 'sphere') {
                let r = Math.sqrt(Math.max(0, cfg.r**2 - val**2)) * scale;
                ctx2d.arc(cx, cy, r, 0, Math.PI*2);
            } else if (currentShape === 'cube') {
                if (Math.abs(val) < cfg.h/2) 
                    ctx2d.rect(cx - cfg.w*scale/2, cy - cfg.d*scale/2, cfg.w*scale, cfg.d*scale);
            } else {
                let halfH = cfg.h / 2;
                if (Math.abs(val) < halfH) {
                    let ratio = (halfH - val) / cfg.h;
                    let currentR = cfg.rTop + (cfg.rBot - cfg.rTop) * ratio;
                    
                    if (currentShape === 'cylinder' || currentShape === 'cone') {
                        ctx2d.arc(cx, cy, currentR * scale, 0, Math.PI*2);
                    } else if (currentShape === 'sq_pyramid') {
                        let side = currentR * scale * 1.414; 
                        ctx2d.rect(cx - side/2, cy - side/2, side, side);
                    } else {
                        drawPolygon(ctx2d, cx, cy, cfg.seg, currentR * scale);
                    }
                }
            }
        } 
        // 縱切 (Vertical)
        else {
            let dist = Math.abs(val);
            let maxHeight = (cfg.h || 4) * scale;
            
            if (currentShape === 'sphere') {
                let r = Math.sqrt(Math.max(0, cfg.r**2 - dist**2)) * scale;
                ctx2d.arc(cx, cy, r, 0, Math.PI*2);
            }
            else if (currentShape === 'cube') {
                 if (dist < cfg.w/2) 
                    ctx2d.rect(cx - cfg.d*scale/2, cy - cfg.h*scale/2, cfg.d*scale, cfg.h*scale);
            }
            else if (currentShape === 'cylinder' || currentShape === 'prism') {
                if (dist < cfg.rBot) {
                    let w_slice = 0;
                    if (currentShape === 'cylinder') w_slice = 2 * Math.sqrt(cfg.rBot**2 - dist**2) * scale;
                    else w_slice = 2 * (cfg.rBot - dist) * scale;
                    if (w_slice > 0) ctx2d.rect(cx - w_slice/2, cy - maxHeight/2, w_slice, maxHeight);
                }
            }
            // 圓錐 (修正邏輯)
            else if (currentShape === 'cone') {
                if (dist < cfg.rBot) {
                    let botW = 2 * Math.sqrt(cfg.rBot**2 - dist**2) * scale;
                    let cutH = cfg.h * (1 - dist/cfg.rBot) * scale;
                    let baseY = cy + maxHeight/2;
                    let topY = baseY - cutH;
                    
                    ctx2d.moveTo(cx - botW/2, baseY); 
                    if (dist < 0.05) {
                        ctx2d.lineTo(cx, topY); // 中間：三角形
                    } else {
                        ctx2d.quadraticCurveTo(cx, topY - (cutH*0.05), cx + botW/2, baseY); // 旁側：雙曲線
                    }
                    ctx2d.lineTo(cx + botW/2, baseY); 
                    ctx2d.closePath(); 
                }
            }
            // 四角錐 (修正邏輯)
            else if (currentShape === 'sq_pyramid') {
                let L = cfg.rBot * Math.sqrt(2); 
                let sideDist = L / 2; 
                if (dist < sideDist) {
                    let botW = L * scale; 
                    let cutH = cfg.h * (1 - dist/sideDist) * scale;
                    let topW = 2 * dist * scale;
                    let baseY = cy + maxHeight/2;
                    let topY = baseY - cutH;
                    ctx2d.moveTo(cx - topW/2, topY);
                    ctx2d.lineTo(cx + topW/2, topY);
                    ctx2d.lineTo(cx + botW/2, baseY);
                    ctx2d.lineTo(cx - botW/2, baseY);
                }
            }
            else if (currentShape === 'tri_pyramid') {
                let R = cfg.rBot;
                if (dist < R) {
                    let botW = 1.732 * (R - dist) * scale; 
                    let cutH = cfg.h * (1 - dist/R) * scale;
                    let baseY = cy + maxHeight/2;
                    let topY = baseY - cutH;
                    ctx2d.moveTo(cx, topY);
                    ctx2d.lineTo(cx + botW/2, baseY);
                    ctx2d.lineTo(cx - botW/2, baseY);
                }
            }
        }

        ctx2d.fill();
        ctx2d.stroke();
    }

    function drawPolygon(ctx, x, y, sides, radius) {
        if (radius <= 0) return;
        ctx.moveTo(x + radius * Math.cos(-Math.PI/2), y + radius * Math.sin(-Math.PI/2));
        for (let i = 1; i <= sides; i++) {
            let angle = i * 2 * Math.PI / sides - Math.PI/2;
            ctx.lineTo(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        if(controls) controls.update(); // 更新控制器

        const val = parseFloat(document.getElementById('slider').value);
        if (cutMode === 'horizontal') {
            slicePlane.position.set(0, val, 0);
        } else {
            slicePlane.position.set(val, 0, 0);
        }
        renderer.render(scene, camera);
    }

    document.getElementById('slider').addEventListener('input', draw2d);
    init();
</script>
</body>
</html>
